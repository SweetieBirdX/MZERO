{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":16052574334135725813,"abi":{"parameters":[{"name":"sender","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"recipient","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"expected_sender_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"expected_recipient_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"expected_message_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"expected_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"61":{"source":"mod zkmail_verification;\n\nuse zkmail_verification::verify_mail;\n\npub fn main(\n    sender: [u8; 32],\n    recipient: [u8; 32],\n    message: [u8; 32],\n    timestamp: u64,\n    expected_sender_hash: [u8; 32],\n    expected_recipient_hash: [u8; 32],\n    expected_message_hash: [u8; 32],\n    expected_timestamp: u64,\n) -> pub bool {\n    verify_mail(\n        sender,\n        recipient,\n        message,\n        timestamp,\n        expected_sender_hash,\n        expected_recipient_hash,\n        expected_message_hash,\n        expected_timestamp,\n    )\n}\n","path":"/mnt/c/Users/eyupe/Desktop/MZERO/mzk/src/main.nr"},"62":{"source":"pub fn verify_mail(\n    sender: [u8; 32],\n    recipient: [u8; 32],\n    message: [u8; 32],\n    timestamp: u64,\n    expected_sender_hash: [u8; 32],\n    expected_recipient_hash: [u8; 32],\n    expected_message_hash: [u8; 32],\n    expected_timestamp: u64,\n) -> bool {\n    let sender_match = sender == expected_sender_hash;\n    let recipient_match = recipient == expected_recipient_hash;\n    let message_match = message == expected_message_hash;\n    let timestamp_match = timestamp == expected_timestamp;\n\n    sender_match & recipient_match & message_match & timestamp_match\n}\n","path":"/mnt/c/Users/eyupe/Desktop/MZERO/mzk/src/zkmail_verification.nr"}},"names":["main"],"brillig_names":["directive_invert"]}